\hypertarget{namespacergbd__slam_1_1utils}{}\doxysection{rgbd\+\_\+slam\+::utils Namespace Reference}
\label{namespacergbd__slam_1_1utils}\index{rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classrgbd__slam_1_1utils_1_1_pose}{Pose}}
\begin{DoxyCompactList}\small\item\em Store a position with variance estimations. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classrgbd__slam_1_1utils_1_1_pose_base}{Pose\+Base}}
\begin{DoxyCompactList}\small\item\em Store a position. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef std\+::vector$<$ \mbox{\hyperlink{classrgbd__slam_1_1utils_1_1_pose}{Pose}}, Eigen\+::aligned\+\_\+allocator$<$ \mbox{\hyperlink{classrgbd__slam_1_1utils_1_1_pose}{Pose}} $>$ $>$ \mbox{\hyperlink{namespacergbd__slam_1_1utils_ad5c3e0ac91a5ac0fa91e12e608cb8399}{pose\+\_\+array}}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
const \mbox{\hyperlink{namespacergbd__slam_a078420ee4217ebf095ba100570679827}{quaternion}} \mbox{\hyperlink{namespacergbd__slam_1_1utils_a689f666ff207fba3031e7f371e2d0a5a}{get\+\_\+quaternion\+\_\+from\+\_\+euler\+\_\+angles}} (const \mbox{\hyperlink{structrgbd__slam_1_1_euler_angles}{Euler\+Angles}} \&euler\+Angles)
\begin{DoxyCompactList}\small\item\em Compute a quaternion from the given euler angles, in radians. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{structrgbd__slam_1_1_euler_angles}{Euler\+Angles}} \mbox{\hyperlink{namespacergbd__slam_1_1utils_a995cd2edc48202cf14bce574a152b0ce}{get\+\_\+euler\+\_\+angles\+\_\+from\+\_\+quaternion}} (const \mbox{\hyperlink{namespacergbd__slam_a078420ee4217ebf095ba100570679827}{quaternion}} \&quat)
\begin{DoxyCompactList}\small\item\em Compute euler angles from a given quaternion. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{namespacergbd__slam_a2877fc3a278a20d5132bcd38e12faf69}{matrix33}} \mbox{\hyperlink{namespacergbd__slam_1_1utils_a07db914662571bbec6e8a1911fa8a117}{get\+\_\+rotation\+\_\+matrix\+\_\+from\+\_\+euler\+\_\+angles}} (const \mbox{\hyperlink{structrgbd__slam_1_1_euler_angles}{Euler\+Angles}} \&euler\+Angles)
\begin{DoxyCompactList}\small\item\em Compute a rotation matrix from a euler angle container. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacergbd__slam_1_1utils_adba3e96e0d019dbd7284e4a6dc4911f3}{is\+\_\+depth\+\_\+valid}} (const double depth)
\begin{DoxyCompactList}\small\item\em Return true is a measurement is in the measurement range. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{structrgbd__slam_1_1world_coordinates}{world\+Coordinates}} \mbox{\hyperlink{namespacergbd__slam_1_1utils_a9dbca5ba1fde9dede66b983bcdd6b8d0}{screen\+\_\+to\+\_\+world\+\_\+coordinates}} (const \mbox{\hyperlink{structrgbd__slam_1_1screen_coordinates}{screen\+Coordinates}} \&screen\+Point, const \mbox{\hyperlink{structrgbd__slam_1_1camera_to_world_matrix}{camera\+To\+World\+Matrix}} \&camera\+To\+World)
\item 
const \mbox{\hyperlink{namespacergbd__slam_a5cbcd8eb5bdfc3609954483b8c18b675}{vector4}} \mbox{\hyperlink{namespacergbd__slam_1_1utils_a31acbfa81adc70ed7a028aee25347ac0}{camera\+\_\+to\+\_\+world\+\_\+coordinates}} (const \mbox{\hyperlink{structrgbd__slam_1_1camera_coordinates}{camera\+Coordinates}} \&camera\+Point, const \mbox{\hyperlink{structrgbd__slam_1_1camera_to_world_matrix}{camera\+To\+World\+Matrix}} \&camera\+To\+World)
\begin{DoxyCompactList}\small\item\em Transform a vector in camera space to a vector in world space. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacergbd__slam_1_1utils_ac606f34d58a2c38df57f52586971f41c}{compute\+\_\+world\+\_\+to\+\_\+screen\+\_\+coordinates}} (const \mbox{\hyperlink{structrgbd__slam_1_1world_coordinates}{world\+Coordinates}} \&position3D, const \mbox{\hyperlink{structrgbd__slam_1_1world_to_camera_matrix}{world\+To\+Camera\+Matrix}} \&world\+To\+Camera, \mbox{\hyperlink{structrgbd__slam_1_1screen_coordinates}{screen\+Coordinates}} \&screen\+Point)
\begin{DoxyCompactList}\small\item\em Transform a point from world to screen coordinate system. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{structrgbd__slam_1_1camera_coordinates}{camera\+Coordinates}} \mbox{\hyperlink{namespacergbd__slam_1_1utils_aa4613bdb56bd3012bd4efae167362569}{world\+\_\+to\+\_\+camera\+\_\+coordinates}} (const \mbox{\hyperlink{structrgbd__slam_1_1world_coordinates}{world\+Coordinates}} \&\mbox{\hyperlink{structrgbd__slam_1_1world_coordinates}{world\+Coordinates}}, const \mbox{\hyperlink{structrgbd__slam_1_1world_to_camera_matrix}{world\+To\+Camera\+Matrix}} \&world\+To\+Camera)
\begin{DoxyCompactList}\small\item\em Transform a vector in world space to a vector in camera space. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{structrgbd__slam_1_1camera_to_world_matrix}{camera\+To\+World\+Matrix}} \mbox{\hyperlink{namespacergbd__slam_1_1utils_acf2041d958f5f63468f142a85b634587}{compute\+\_\+camera\+\_\+to\+\_\+world\+\_\+transform}} (const \mbox{\hyperlink{namespacergbd__slam_a078420ee4217ebf095ba100570679827}{quaternion}} \&rotation, const \mbox{\hyperlink{namespacergbd__slam_a1c642e1c4dfceaa8c7409331bfc10b6b}{vector3}} \&position)
\begin{DoxyCompactList}\small\item\em Given a camera pose, returns a transformation matrix to convert a camera point (uvd) to world point (xyz) \end{DoxyCompactList}\item 
const \mbox{\hyperlink{structrgbd__slam_1_1world_to_camera_matrix}{world\+To\+Camera\+Matrix}} \mbox{\hyperlink{namespacergbd__slam_1_1utils_a80a5c96230a6cced4d4999c60ea659e9}{compute\+\_\+world\+\_\+to\+\_\+camera\+\_\+transform}} (const \mbox{\hyperlink{namespacergbd__slam_a078420ee4217ebf095ba100570679827}{quaternion}} \&rotation, const \mbox{\hyperlink{namespacergbd__slam_a1c642e1c4dfceaa8c7409331bfc10b6b}{vector3}} \&position)
\begin{DoxyCompactList}\small\item\em Given a camera pose, returns a transformation matrix to convert a world point (xyz) to camera point (uvd) \end{DoxyCompactList}\item 
const \mbox{\hyperlink{structrgbd__slam_1_1world_to_camera_matrix}{world\+To\+Camera\+Matrix}} \mbox{\hyperlink{namespacergbd__slam_1_1utils_a0374f99788406cd572d51692961af33a}{compute\+\_\+world\+\_\+to\+\_\+camera\+\_\+transform}} (const \mbox{\hyperlink{structrgbd__slam_1_1camera_to_world_matrix}{camera\+To\+World\+Matrix}} \&camera\+To\+World)
\item 
const \mbox{\hyperlink{namespacergbd__slam_a2877fc3a278a20d5132bcd38e12faf69}{matrix33}} \mbox{\hyperlink{namespacergbd__slam_1_1utils_a65406b55752913e8a72b15c732fcd699}{get\+\_\+screen\+\_\+point\+\_\+covariance}} (const \mbox{\hyperlink{structrgbd__slam_1_1screen_coordinates}{screen\+Coordinates}} \&\mbox{\hyperlink{structrgbd__slam_1_1screen_coordinates}{screen\+Coordinates}})
\begin{DoxyCompactList}\small\item\em compute a covariance matrix for a screen point associated with a depth measurement \end{DoxyCompactList}\item 
const \mbox{\hyperlink{namespacergbd__slam_a2877fc3a278a20d5132bcd38e12faf69}{matrix33}} \mbox{\hyperlink{namespacergbd__slam_1_1utils_a3f2bd96814341dcb6a1418fce8e842df}{get\+\_\+screen\+\_\+point\+\_\+covariance}} (const \mbox{\hyperlink{structrgbd__slam_1_1camera_coordinates}{camera\+Coordinates}} \&camera\+Point, const \mbox{\hyperlink{namespacergbd__slam_a2877fc3a278a20d5132bcd38e12faf69}{matrix33}} \&world\+Point\+Covariance)
\begin{DoxyCompactList}\small\item\em Compute a screen point covariance from a given camera point. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{namespacergbd__slam_a2877fc3a278a20d5132bcd38e12faf69}{matrix33}} \mbox{\hyperlink{namespacergbd__slam_1_1utils_af1c875ecbbef7363643107ddd5b8fdbb}{get\+\_\+world\+\_\+point\+\_\+covariance}} (const \mbox{\hyperlink{structrgbd__slam_1_1screen_coordinates}{screen\+Coordinates}} \&screen\+Point)
\begin{DoxyCompactList}\small\item\em Compute the associated Gaussian error of a screen point when it will be transformed to world point. This function will internaly compute the covariance of the screen point. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{namespacergbd__slam_a2877fc3a278a20d5132bcd38e12faf69}{matrix33}} \mbox{\hyperlink{namespacergbd__slam_1_1utils_a15a5da9934a8f4ec423e77e26bff88ba}{get\+\_\+world\+\_\+point\+\_\+covariance}} (const \mbox{\hyperlink{structrgbd__slam_1_1screen_coordinates}{screen\+Coordinates}} \&screen\+Point, const \mbox{\hyperlink{namespacergbd__slam_a2877fc3a278a20d5132bcd38e12faf69}{matrix33}} \&screen\+Point\+Covariance)
\begin{DoxyCompactList}\small\item\em Compute the associated Gaussian error of a screen point when it will be transformed to world point. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacergbd__slam_1_1utils_a58e29e70d22c5d0a1b86c820acb7159e}{compute\+\_\+pose\+\_\+variance}} (const \mbox{\hyperlink{classrgbd__slam_1_1utils_1_1_pose}{Pose}} \&pose, const \mbox{\hyperlink{namespacergbd__slam_1_1matches__containers_a69e137115cf0342c9d0dcc61d0823af9}{matches\+\_\+containers\+::match\+\_\+point\+\_\+container}} \&matched\+Points, \mbox{\hyperlink{namespacergbd__slam_a1c642e1c4dfceaa8c7409331bfc10b6b}{vector3}} \&pose\+Variance)
\begin{DoxyCompactList}\small\item\em Compute the variance of the final pose in X Y Z. \end{DoxyCompactList}\item 
const \mbox{\hyperlink{namespacergbd__slam_a2877fc3a278a20d5132bcd38e12faf69}{matrix33}} \mbox{\hyperlink{namespacergbd__slam_1_1utils_a25aefd4d0548c521c2fc7818f3ace9c5}{compute\+\_\+pose\+\_\+covariance}} (const \mbox{\hyperlink{classrgbd__slam_1_1utils_1_1_pose}{Pose}} \&pose)
\begin{DoxyCompactList}\small\item\em Compute a pose covariance matrix from a pose. \end{DoxyCompactList}\item 
Eigen\+::\+Vector\+Xd \mbox{\hyperlink{namespacergbd__slam_1_1utils_a59cfb8a0e06b13de53e5a3a82719ca7c}{get\+\_\+distance}} (const Eigen\+::\+Vector\+Xd \&pointA, const Eigen\+::\+Vector\+Xd \&pointB)
\begin{DoxyCompactList}\small\item\em Compute a signed distance between two points. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{namespacergbd__slam_1_1utils_a173685d2c7d390b356cbb92a2fc6f34e}{get\+\_\+distance\+\_\+euclidean}} (const Eigen\+::\+Vector\+Xd \&pointA, const Eigen\+::\+Vector\+Xd \&pointB)
\begin{DoxyCompactList}\small\item\em Compute a distance between two 3D points. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{namespacergbd__slam_1_1utils_a02f7a096d8a6742b7f6a4f375771d0cc}{get\+\_\+distance\+\_\+manhattan}} (const Eigen\+::\+Vector\+Xd \&pointA, const Eigen\+::\+Vector\+Xd \&pointB)
\begin{DoxyCompactList}\small\item\em Compute a distance between two 3D points. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacergbd__slam_acbfe158267b4d08e84815de6e0fc4cda}{vector2}} \mbox{\hyperlink{namespacergbd__slam_1_1utils_a85e268d155d8c8f2b4fdb5ee0b1c8554}{get\+\_\+3\+D\+\_\+to\+\_\+2\+D\+\_\+distance\+\_\+2D}} (const \mbox{\hyperlink{structrgbd__slam_1_1world_coordinates}{world\+Coordinates}} \&world\+Point, const \mbox{\hyperlink{structrgbd__slam_1_1screen_coordinates}{screen\+Coordinates}} \&camera\+Point, const \mbox{\hyperlink{structrgbd__slam_1_1world_to_camera_matrix}{world\+To\+Camera\+Matrix}} \&world\+To\+Camera)
\begin{DoxyCompactList}\small\item\em Compute a signed 2D distance between a world point and a camera point, by retroprojecting the world point to camera space. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{namespacergbd__slam_1_1utils_ae3480fca10bc94fc032ec4092eeae805}{get\+\_\+3\+D\+\_\+to\+\_\+2\+D\+\_\+distance}} (const \mbox{\hyperlink{structrgbd__slam_1_1world_coordinates}{world\+Coordinates}} \&world\+Point, const \mbox{\hyperlink{structrgbd__slam_1_1screen_coordinates}{screen\+Coordinates}} \&camera\+Point, const \mbox{\hyperlink{structrgbd__slam_1_1world_to_camera_matrix}{world\+To\+Camera\+Matrix}} \&world\+To\+Camera)
\begin{DoxyCompactList}\small\item\em Compute a distance between a world point and a camera point, by retroprojecting the world point to camera space. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacergbd__slam_a1c642e1c4dfceaa8c7409331bfc10b6b}{vector3}} \mbox{\hyperlink{namespacergbd__slam_1_1utils_add957a0c9ceca7d234d4fe19140a1bc9}{get\+\_\+3\+D\+\_\+to\+\_\+3\+D\+\_\+distance\+\_\+3D}} (const \mbox{\hyperlink{structrgbd__slam_1_1world_coordinates}{world\+Coordinates}} \&world\+Point, const \mbox{\hyperlink{structrgbd__slam_1_1screen_coordinates}{screen\+Coordinates}} \&camera\+Point, const \mbox{\hyperlink{structrgbd__slam_1_1camera_to_world_matrix}{camera\+To\+World\+Matrix}} \&camera\+To\+World)
\begin{DoxyCompactList}\small\item\em Compute a signed distance between a world point and a 3D point in camera space, by projecting the camera point to world space. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{namespacergbd__slam_1_1utils_a714b3583dcb988faab880c694598b1eb}{get\+\_\+3\+D\+\_\+to\+\_\+3\+D\+\_\+distance}} (const \mbox{\hyperlink{structrgbd__slam_1_1world_coordinates}{world\+Coordinates}} \&world\+Point, const \mbox{\hyperlink{structrgbd__slam_1_1screen_coordinates}{screen\+Coordinates}} \&camera\+Point, const \mbox{\hyperlink{structrgbd__slam_1_1camera_to_world_matrix}{camera\+To\+World\+Matrix}} \&camera\+To\+World)
\begin{DoxyCompactList}\small\item\em Compute a distance between a world point and a 3D point in camera space, by projecting the camera point to world space. \end{DoxyCompactList}\item 
std\+::ostream \& \mbox{\hyperlink{namespacergbd__slam_1_1utils_a7830f2322d077dd3b0659ac1226daa5f}{operator$<$$<$}} (std\+::ostream \&os, const \mbox{\hyperlink{classrgbd__slam_1_1utils_1_1_pose_base}{Pose\+Base}} \&pose)
\item 
std\+::ostream \& \mbox{\hyperlink{namespacergbd__slam_1_1utils_a1f943d571d918b61309edcd6d98f848a}{operator$<$$<$}} (std\+::ostream \&os, const \mbox{\hyperlink{classrgbd__slam_1_1utils_1_1_pose}{Pose}} \&pose)
\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const double \mbox{\hyperlink{namespacergbd__slam_1_1utils_afb0e42e07f9e12d67543af504e440506}{MIN\+\_\+\+DEPTH\+\_\+\+DISTANCE}} = 40
\item 
const double \mbox{\hyperlink{namespacergbd__slam_1_1utils_a7c711197a8776f474dea42a34838b675}{MAX\+\_\+\+DEPTH\+\_\+\+DISTANCE}} = 6000
\end{DoxyCompactItemize}


\doxysubsection{Typedef Documentation}
\mbox{\Hypertarget{namespacergbd__slam_1_1utils_ad5c3e0ac91a5ac0fa91e12e608cb8399}\label{namespacergbd__slam_1_1utils_ad5c3e0ac91a5ac0fa91e12e608cb8399}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!pose\_array@{pose\_array}}
\index{pose\_array@{pose\_array}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{pose\_array}{pose\_array}}
{\footnotesize\ttfamily typedef std\+::vector$<$\mbox{\hyperlink{classrgbd__slam_1_1utils_1_1_pose}{Pose}}, Eigen\+::aligned\+\_\+allocator$<$\mbox{\hyperlink{classrgbd__slam_1_1utils_1_1_pose}{Pose}}$>$ $>$ \mbox{\hyperlink{namespacergbd__slam_1_1utils_ad5c3e0ac91a5ac0fa91e12e608cb8399}{rgbd\+\_\+slam\+::utils\+::pose\+\_\+array}}}



\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespacergbd__slam_1_1utils_a31acbfa81adc70ed7a028aee25347ac0}\label{namespacergbd__slam_1_1utils_a31acbfa81adc70ed7a028aee25347ac0}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!camera\_to\_world\_coordinates@{camera\_to\_world\_coordinates}}
\index{camera\_to\_world\_coordinates@{camera\_to\_world\_coordinates}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{camera\_to\_world\_coordinates()}{camera\_to\_world\_coordinates()}}
{\footnotesize\ttfamily const \mbox{\hyperlink{namespacergbd__slam_a5cbcd8eb5bdfc3609954483b8c18b675}{vector4}} rgbd\+\_\+slam\+::utils\+::camera\+\_\+to\+\_\+world\+\_\+coordinates (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structrgbd__slam_1_1camera_coordinates}{camera\+Coordinates}} \&}]{camera\+Point,  }\item[{const \mbox{\hyperlink{structrgbd__slam_1_1camera_to_world_matrix}{camera\+To\+World\+Matrix}} \&}]{camera\+To\+World }\end{DoxyParamCaption})}



Transform a vector in camera space to a vector in world space. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em camera\+Point} & A vector in camera space \\
\hline
\mbox{\texttt{ in}}  & {\em camera\+To\+World} & Matrix to transform local to world coordinates\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector in world space 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacergbd__slam_1_1utils_acf2041d958f5f63468f142a85b634587}\label{namespacergbd__slam_1_1utils_acf2041d958f5f63468f142a85b634587}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!compute\_camera\_to\_world\_transform@{compute\_camera\_to\_world\_transform}}
\index{compute\_camera\_to\_world\_transform@{compute\_camera\_to\_world\_transform}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{compute\_camera\_to\_world\_transform()}{compute\_camera\_to\_world\_transform()}}
{\footnotesize\ttfamily const \mbox{\hyperlink{structrgbd__slam_1_1camera_to_world_matrix}{camera\+To\+World\+Matrix}} rgbd\+\_\+slam\+::utils\+::compute\+\_\+camera\+\_\+to\+\_\+world\+\_\+transform (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacergbd__slam_a078420ee4217ebf095ba100570679827}{quaternion}} \&}]{rotation,  }\item[{const \mbox{\hyperlink{namespacergbd__slam_a1c642e1c4dfceaa8c7409331bfc10b6b}{vector3}} \&}]{position }\end{DoxyParamCaption})}



Given a camera pose, returns a transformation matrix to convert a camera point (uvd) to world point (xyz) 

\mbox{\Hypertarget{namespacergbd__slam_1_1utils_a25aefd4d0548c521c2fc7818f3ace9c5}\label{namespacergbd__slam_1_1utils_a25aefd4d0548c521c2fc7818f3ace9c5}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!compute\_pose\_covariance@{compute\_pose\_covariance}}
\index{compute\_pose\_covariance@{compute\_pose\_covariance}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{compute\_pose\_covariance()}{compute\_pose\_covariance()}}
{\footnotesize\ttfamily const \mbox{\hyperlink{namespacergbd__slam_a2877fc3a278a20d5132bcd38e12faf69}{matrix33}} rgbd\+\_\+slam\+::utils\+::compute\+\_\+pose\+\_\+covariance (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classrgbd__slam_1_1utils_1_1_pose}{Pose}} \&}]{pose }\end{DoxyParamCaption})}



Compute a pose covariance matrix from a pose. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em pose} & The pose to analyze \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacergbd__slam_1_1utils_a58e29e70d22c5d0a1b86c820acb7159e}\label{namespacergbd__slam_1_1utils_a58e29e70d22c5d0a1b86c820acb7159e}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!compute\_pose\_variance@{compute\_pose\_variance}}
\index{compute\_pose\_variance@{compute\_pose\_variance}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{compute\_pose\_variance()}{compute\_pose\_variance()}}
{\footnotesize\ttfamily bool rgbd\+\_\+slam\+::utils\+::compute\+\_\+pose\+\_\+variance (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classrgbd__slam_1_1utils_1_1_pose}{Pose}} \&}]{pose,  }\item[{const \mbox{\hyperlink{namespacergbd__slam_1_1matches__containers_a69e137115cf0342c9d0dcc61d0823af9}{matches\+\_\+containers\+::match\+\_\+point\+\_\+container}} \&}]{matched\+Points,  }\item[{\mbox{\hyperlink{namespacergbd__slam_a1c642e1c4dfceaa8c7409331bfc10b6b}{vector3}} \&}]{pose\+Variance }\end{DoxyParamCaption})}



Compute the variance of the final pose in X Y Z. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em pose} & The pose to compute the variance of \\
\hline
\mbox{\texttt{ in}}  & {\em matched\+Points} & A container of matched features (inliers) \\
\hline
\mbox{\texttt{ out}}  & {\em pose\+Variance} & If the function returns true, then this is the estimated position variance estimated from matched points\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the variance was estimated 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacergbd__slam_1_1utils_a0374f99788406cd572d51692961af33a}\label{namespacergbd__slam_1_1utils_a0374f99788406cd572d51692961af33a}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!compute\_world\_to\_camera\_transform@{compute\_world\_to\_camera\_transform}}
\index{compute\_world\_to\_camera\_transform@{compute\_world\_to\_camera\_transform}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{compute\_world\_to\_camera\_transform()}{compute\_world\_to\_camera\_transform()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily const \mbox{\hyperlink{structrgbd__slam_1_1world_to_camera_matrix}{world\+To\+Camera\+Matrix}} rgbd\+\_\+slam\+::utils\+::compute\+\_\+world\+\_\+to\+\_\+camera\+\_\+transform (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structrgbd__slam_1_1camera_to_world_matrix}{camera\+To\+World\+Matrix}} \&}]{camera\+To\+World }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacergbd__slam_1_1utils_a80a5c96230a6cced4d4999c60ea659e9}\label{namespacergbd__slam_1_1utils_a80a5c96230a6cced4d4999c60ea659e9}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!compute\_world\_to\_camera\_transform@{compute\_world\_to\_camera\_transform}}
\index{compute\_world\_to\_camera\_transform@{compute\_world\_to\_camera\_transform}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{compute\_world\_to\_camera\_transform()}{compute\_world\_to\_camera\_transform()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily const \mbox{\hyperlink{structrgbd__slam_1_1world_to_camera_matrix}{world\+To\+Camera\+Matrix}} rgbd\+\_\+slam\+::utils\+::compute\+\_\+world\+\_\+to\+\_\+camera\+\_\+transform (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacergbd__slam_a078420ee4217ebf095ba100570679827}{quaternion}} \&}]{rotation,  }\item[{const \mbox{\hyperlink{namespacergbd__slam_a1c642e1c4dfceaa8c7409331bfc10b6b}{vector3}} \&}]{position }\end{DoxyParamCaption})}



Given a camera pose, returns a transformation matrix to convert a world point (xyz) to camera point (uvd) 

\mbox{\Hypertarget{namespacergbd__slam_1_1utils_ac606f34d58a2c38df57f52586971f41c}\label{namespacergbd__slam_1_1utils_ac606f34d58a2c38df57f52586971f41c}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!compute\_world\_to\_screen\_coordinates@{compute\_world\_to\_screen\_coordinates}}
\index{compute\_world\_to\_screen\_coordinates@{compute\_world\_to\_screen\_coordinates}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{compute\_world\_to\_screen\_coordinates()}{compute\_world\_to\_screen\_coordinates()}}
{\footnotesize\ttfamily bool rgbd\+\_\+slam\+::utils\+::compute\+\_\+world\+\_\+to\+\_\+screen\+\_\+coordinates (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structrgbd__slam_1_1world_coordinates}{world\+Coordinates}} \&}]{position3D,  }\item[{const \mbox{\hyperlink{structrgbd__slam_1_1world_to_camera_matrix}{world\+To\+Camera\+Matrix}} \&}]{world\+To\+Camera,  }\item[{\mbox{\hyperlink{structrgbd__slam_1_1screen_coordinates}{screen\+Coordinates}} \&}]{screen\+Point }\end{DoxyParamCaption})}



Transform a point from world to screen coordinate system. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em position3D} & Coordinates of the detected point (world coordinates) \\
\hline
\mbox{\texttt{ in}}  & {\em world\+To\+Camera} & Matrix to transform the world to a local coordinate system \\
\hline
\mbox{\texttt{ out}}  & {\em screen\+Point} & The point screen coordinates, if the function returned true\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the screen position is valid 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacergbd__slam_1_1utils_ae3480fca10bc94fc032ec4092eeae805}\label{namespacergbd__slam_1_1utils_ae3480fca10bc94fc032ec4092eeae805}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!get\_3D\_to\_2D\_distance@{get\_3D\_to\_2D\_distance}}
\index{get\_3D\_to\_2D\_distance@{get\_3D\_to\_2D\_distance}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{get\_3D\_to\_2D\_distance()}{get\_3D\_to\_2D\_distance()}}
{\footnotesize\ttfamily double rgbd\+\_\+slam\+::utils\+::get\+\_\+3\+D\+\_\+to\+\_\+2\+D\+\_\+distance (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structrgbd__slam_1_1world_coordinates}{world\+Coordinates}} \&}]{world\+Point,  }\item[{const \mbox{\hyperlink{structrgbd__slam_1_1screen_coordinates}{screen\+Coordinates}} \&}]{camera\+Point,  }\item[{const \mbox{\hyperlink{structrgbd__slam_1_1world_to_camera_matrix}{world\+To\+Camera\+Matrix}} \&}]{world\+To\+Camera }\end{DoxyParamCaption})}



Compute a distance between a world point and a camera point, by retroprojecting the world point to camera space. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em world\+Point} & A 3D point in world space \\
\hline
\mbox{\texttt{ in}}  & {\em camera\+Point} & A point in camera space. Only the x and y components will be used \\
\hline
\mbox{\texttt{ in}}  & {\em world\+To\+Camera} & A transformation matrix to convert from world to camera space \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an unsigned distance in camera space (pixels) 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacergbd__slam_1_1utils_a85e268d155d8c8f2b4fdb5ee0b1c8554}\label{namespacergbd__slam_1_1utils_a85e268d155d8c8f2b4fdb5ee0b1c8554}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!get\_3D\_to\_2D\_distance\_2D@{get\_3D\_to\_2D\_distance\_2D}}
\index{get\_3D\_to\_2D\_distance\_2D@{get\_3D\_to\_2D\_distance\_2D}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{get\_3D\_to\_2D\_distance\_2D()}{get\_3D\_to\_2D\_distance\_2D()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacergbd__slam_acbfe158267b4d08e84815de6e0fc4cda}{vector2}} rgbd\+\_\+slam\+::utils\+::get\+\_\+3\+D\+\_\+to\+\_\+2\+D\+\_\+distance\+\_\+2D (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structrgbd__slam_1_1world_coordinates}{world\+Coordinates}} \&}]{world\+Point,  }\item[{const \mbox{\hyperlink{structrgbd__slam_1_1screen_coordinates}{screen\+Coordinates}} \&}]{camera\+Point,  }\item[{const \mbox{\hyperlink{structrgbd__slam_1_1world_to_camera_matrix}{world\+To\+Camera\+Matrix}} \&}]{world\+To\+Camera }\end{DoxyParamCaption})}



Compute a signed 2D distance between a world point and a camera point, by retroprojecting the world point to camera space. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em world\+Point} & A 3D point in world space \\
\hline
\mbox{\texttt{ in}}  & {\em camera\+Point} & A point in camera space. Only the x and y components will be used \\
\hline
\mbox{\texttt{ in}}  & {\em world\+To\+Camera} & A transformation matrix to convert from world to camera space \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a 2D signed distance in camera space (pixels) 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacergbd__slam_1_1utils_a714b3583dcb988faab880c694598b1eb}\label{namespacergbd__slam_1_1utils_a714b3583dcb988faab880c694598b1eb}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!get\_3D\_to\_3D\_distance@{get\_3D\_to\_3D\_distance}}
\index{get\_3D\_to\_3D\_distance@{get\_3D\_to\_3D\_distance}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{get\_3D\_to\_3D\_distance()}{get\_3D\_to\_3D\_distance()}}
{\footnotesize\ttfamily double rgbd\+\_\+slam\+::utils\+::get\+\_\+3\+D\+\_\+to\+\_\+3\+D\+\_\+distance (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structrgbd__slam_1_1world_coordinates}{world\+Coordinates}} \&}]{world\+Point,  }\item[{const \mbox{\hyperlink{structrgbd__slam_1_1screen_coordinates}{screen\+Coordinates}} \&}]{camera\+Point,  }\item[{const \mbox{\hyperlink{structrgbd__slam_1_1camera_to_world_matrix}{camera\+To\+World\+Matrix}} \&}]{camera\+To\+World }\end{DoxyParamCaption})}



Compute a distance between a world point and a 3D point in camera space, by projecting the camera point to world space. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em world\+Point} & A 3D point in world space \\
\hline
\mbox{\texttt{ in}}  & {\em camera\+Point} & A 3D point in camera space \\
\hline
\mbox{\texttt{ in}}  & {\em camera\+To\+World} & A matrix to convert from camera to world space \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The unsigned distance in world space 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacergbd__slam_1_1utils_add957a0c9ceca7d234d4fe19140a1bc9}\label{namespacergbd__slam_1_1utils_add957a0c9ceca7d234d4fe19140a1bc9}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!get\_3D\_to\_3D\_distance\_3D@{get\_3D\_to\_3D\_distance\_3D}}
\index{get\_3D\_to\_3D\_distance\_3D@{get\_3D\_to\_3D\_distance\_3D}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{get\_3D\_to\_3D\_distance\_3D()}{get\_3D\_to\_3D\_distance\_3D()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacergbd__slam_a1c642e1c4dfceaa8c7409331bfc10b6b}{vector3}} rgbd\+\_\+slam\+::utils\+::get\+\_\+3\+D\+\_\+to\+\_\+3\+D\+\_\+distance\+\_\+3D (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structrgbd__slam_1_1world_coordinates}{world\+Coordinates}} \&}]{world\+Point,  }\item[{const \mbox{\hyperlink{structrgbd__slam_1_1screen_coordinates}{screen\+Coordinates}} \&}]{camera\+Point,  }\item[{const \mbox{\hyperlink{structrgbd__slam_1_1camera_to_world_matrix}{camera\+To\+World\+Matrix}} \&}]{camera\+To\+World }\end{DoxyParamCaption})}



Compute a signed distance between a world point and a 3D point in camera space, by projecting the camera point to world space. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em world\+Point} & A 3D point in world space \\
\hline
\mbox{\texttt{ in}}  & {\em camera\+Point} & A 3D point in camera space \\
\hline
\mbox{\texttt{ in}}  & {\em camera\+To\+World} & A matrix to convert from camera to world space \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The 3D signed distance in world space 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacergbd__slam_1_1utils_a59cfb8a0e06b13de53e5a3a82719ca7c}\label{namespacergbd__slam_1_1utils_a59cfb8a0e06b13de53e5a3a82719ca7c}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!get\_distance@{get\_distance}}
\index{get\_distance@{get\_distance}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{get\_distance()}{get\_distance()}}
{\footnotesize\ttfamily Eigen\+::\+Vector\+Xd rgbd\+\_\+slam\+::utils\+::get\+\_\+distance (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector\+Xd \&}]{pointA,  }\item[{const Eigen\+::\+Vector\+Xd \&}]{pointB }\end{DoxyParamCaption})}



Compute a signed distance between two points. 

\mbox{\Hypertarget{namespacergbd__slam_1_1utils_a173685d2c7d390b356cbb92a2fc6f34e}\label{namespacergbd__slam_1_1utils_a173685d2c7d390b356cbb92a2fc6f34e}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!get\_distance\_euclidean@{get\_distance\_euclidean}}
\index{get\_distance\_euclidean@{get\_distance\_euclidean}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{get\_distance\_euclidean()}{get\_distance\_euclidean()}}
{\footnotesize\ttfamily double rgbd\+\_\+slam\+::utils\+::get\+\_\+distance\+\_\+euclidean (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector\+Xd \&}]{pointA,  }\item[{const Eigen\+::\+Vector\+Xd \&}]{pointB }\end{DoxyParamCaption})}



Compute a distance between two 3D points. 

\begin{DoxyReturn}{Returns}
an unsigned euclidean distance 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacergbd__slam_1_1utils_a02f7a096d8a6742b7f6a4f375771d0cc}\label{namespacergbd__slam_1_1utils_a02f7a096d8a6742b7f6a4f375771d0cc}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!get\_distance\_manhattan@{get\_distance\_manhattan}}
\index{get\_distance\_manhattan@{get\_distance\_manhattan}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{get\_distance\_manhattan()}{get\_distance\_manhattan()}}
{\footnotesize\ttfamily double rgbd\+\_\+slam\+::utils\+::get\+\_\+distance\+\_\+manhattan (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector\+Xd \&}]{pointA,  }\item[{const Eigen\+::\+Vector\+Xd \&}]{pointB }\end{DoxyParamCaption})}



Compute a distance between two 3D points. 

\begin{DoxyReturn}{Returns}
an unsigned manhattan distance 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacergbd__slam_1_1utils_a995cd2edc48202cf14bce574a152b0ce}\label{namespacergbd__slam_1_1utils_a995cd2edc48202cf14bce574a152b0ce}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!get\_euler\_angles\_from\_quaternion@{get\_euler\_angles\_from\_quaternion}}
\index{get\_euler\_angles\_from\_quaternion@{get\_euler\_angles\_from\_quaternion}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{get\_euler\_angles\_from\_quaternion()}{get\_euler\_angles\_from\_quaternion()}}
{\footnotesize\ttfamily const \mbox{\hyperlink{structrgbd__slam_1_1_euler_angles}{Euler\+Angles}} rgbd\+\_\+slam\+::utils\+::get\+\_\+euler\+\_\+angles\+\_\+from\+\_\+quaternion (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespacergbd__slam_a078420ee4217ebf095ba100570679827}{quaternion}} \&}]{quat }\end{DoxyParamCaption})}



Compute euler angles from a given quaternion. 

\mbox{\Hypertarget{namespacergbd__slam_1_1utils_a689f666ff207fba3031e7f371e2d0a5a}\label{namespacergbd__slam_1_1utils_a689f666ff207fba3031e7f371e2d0a5a}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!get\_quaternion\_from\_euler\_angles@{get\_quaternion\_from\_euler\_angles}}
\index{get\_quaternion\_from\_euler\_angles@{get\_quaternion\_from\_euler\_angles}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{get\_quaternion\_from\_euler\_angles()}{get\_quaternion\_from\_euler\_angles()}}
{\footnotesize\ttfamily const \mbox{\hyperlink{namespacergbd__slam_a078420ee4217ebf095ba100570679827}{quaternion}} rgbd\+\_\+slam\+::utils\+::get\+\_\+quaternion\+\_\+from\+\_\+euler\+\_\+angles (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structrgbd__slam_1_1_euler_angles}{Euler\+Angles}} \&}]{euler\+Angles }\end{DoxyParamCaption})}



Compute a quaternion from the given euler angles, in radians. 

\mbox{\Hypertarget{namespacergbd__slam_1_1utils_a07db914662571bbec6e8a1911fa8a117}\label{namespacergbd__slam_1_1utils_a07db914662571bbec6e8a1911fa8a117}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!get\_rotation\_matrix\_from\_euler\_angles@{get\_rotation\_matrix\_from\_euler\_angles}}
\index{get\_rotation\_matrix\_from\_euler\_angles@{get\_rotation\_matrix\_from\_euler\_angles}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{get\_rotation\_matrix\_from\_euler\_angles()}{get\_rotation\_matrix\_from\_euler\_angles()}}
{\footnotesize\ttfamily const \mbox{\hyperlink{namespacergbd__slam_a2877fc3a278a20d5132bcd38e12faf69}{matrix33}} rgbd\+\_\+slam\+::utils\+::get\+\_\+rotation\+\_\+matrix\+\_\+from\+\_\+euler\+\_\+angles (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structrgbd__slam_1_1_euler_angles}{Euler\+Angles}} \&}]{euler\+Angles }\end{DoxyParamCaption})}



Compute a rotation matrix from a euler angle container. 

\mbox{\Hypertarget{namespacergbd__slam_1_1utils_a3f2bd96814341dcb6a1418fce8e842df}\label{namespacergbd__slam_1_1utils_a3f2bd96814341dcb6a1418fce8e842df}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!get\_screen\_point\_covariance@{get\_screen\_point\_covariance}}
\index{get\_screen\_point\_covariance@{get\_screen\_point\_covariance}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{get\_screen\_point\_covariance()}{get\_screen\_point\_covariance()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily const \mbox{\hyperlink{namespacergbd__slam_a2877fc3a278a20d5132bcd38e12faf69}{matrix33}} rgbd\+\_\+slam\+::utils\+::get\+\_\+screen\+\_\+point\+\_\+covariance (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structrgbd__slam_1_1camera_coordinates}{camera\+Coordinates}} \&}]{camera\+Point,  }\item[{const \mbox{\hyperlink{namespacergbd__slam_a2877fc3a278a20d5132bcd38e12faf69}{matrix33}} \&}]{world\+Point\+Covariance }\end{DoxyParamCaption})}



Compute a screen point covariance from a given camera point. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em camera\+Point} & The coordinates of this 3D point, in camera space \\
\hline
\mbox{\texttt{ in}}  & {\em world\+Point\+Covariance} & The covariance associated with this world point \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacergbd__slam_1_1utils_a65406b55752913e8a72b15c732fcd699}\label{namespacergbd__slam_1_1utils_a65406b55752913e8a72b15c732fcd699}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!get\_screen\_point\_covariance@{get\_screen\_point\_covariance}}
\index{get\_screen\_point\_covariance@{get\_screen\_point\_covariance}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{get\_screen\_point\_covariance()}{get\_screen\_point\_covariance()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily const \mbox{\hyperlink{namespacergbd__slam_a2877fc3a278a20d5132bcd38e12faf69}{matrix33}} rgbd\+\_\+slam\+::utils\+::get\+\_\+screen\+\_\+point\+\_\+covariance (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structrgbd__slam_1_1screen_coordinates}{screen\+Coordinates}} \&}]{screen\+Coordinates }\end{DoxyParamCaption})}



compute a covariance matrix for a screen point associated with a depth measurement 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em \mbox{\hyperlink{structrgbd__slam_1_1screen_coordinates}{screen\+Coordinates}}} & The coordinates of this point, in screen space\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A 3x3 covariance matrix. It should be diagonal 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacergbd__slam_1_1utils_af1c875ecbbef7363643107ddd5b8fdbb}\label{namespacergbd__slam_1_1utils_af1c875ecbbef7363643107ddd5b8fdbb}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!get\_world\_point\_covariance@{get\_world\_point\_covariance}}
\index{get\_world\_point\_covariance@{get\_world\_point\_covariance}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{get\_world\_point\_covariance()}{get\_world\_point\_covariance()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily const \mbox{\hyperlink{namespacergbd__slam_a2877fc3a278a20d5132bcd38e12faf69}{matrix33}} rgbd\+\_\+slam\+::utils\+::get\+\_\+world\+\_\+point\+\_\+covariance (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structrgbd__slam_1_1screen_coordinates}{screen\+Coordinates}} \&}]{screen\+Point }\end{DoxyParamCaption})}



Compute the associated Gaussian error of a screen point when it will be transformed to world point. This function will internaly compute the covariance of the screen point. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em screen\+Point} & The 2D point in screen coordinates\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the covariance of the 3D world point 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacergbd__slam_1_1utils_a15a5da9934a8f4ec423e77e26bff88ba}\label{namespacergbd__slam_1_1utils_a15a5da9934a8f4ec423e77e26bff88ba}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!get\_world\_point\_covariance@{get\_world\_point\_covariance}}
\index{get\_world\_point\_covariance@{get\_world\_point\_covariance}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{get\_world\_point\_covariance()}{get\_world\_point\_covariance()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily const \mbox{\hyperlink{namespacergbd__slam_a2877fc3a278a20d5132bcd38e12faf69}{matrix33}} rgbd\+\_\+slam\+::utils\+::get\+\_\+world\+\_\+point\+\_\+covariance (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structrgbd__slam_1_1screen_coordinates}{screen\+Coordinates}} \&}]{screen\+Point,  }\item[{const \mbox{\hyperlink{namespacergbd__slam_a2877fc3a278a20d5132bcd38e12faf69}{matrix33}} \&}]{screen\+Point\+Covariance }\end{DoxyParamCaption})}



Compute the associated Gaussian error of a screen point when it will be transformed to world point. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em screen\+Point} & The 2D point in screen coordinates \\
\hline
\mbox{\texttt{ in}}  & {\em screen\+Point\+Covariance} & The covariance matrix associated with a point in screen space\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the covariance of the 3D world point 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacergbd__slam_1_1utils_adba3e96e0d019dbd7284e4a6dc4911f3}\label{namespacergbd__slam_1_1utils_adba3e96e0d019dbd7284e4a6dc4911f3}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!is\_depth\_valid@{is\_depth\_valid}}
\index{is\_depth\_valid@{is\_depth\_valid}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{is\_depth\_valid()}{is\_depth\_valid()}}
{\footnotesize\ttfamily bool rgbd\+\_\+slam\+::utils\+::is\+\_\+depth\+\_\+valid (\begin{DoxyParamCaption}\item[{const double}]{depth }\end{DoxyParamCaption})}



Return true is a measurement is in the measurement range. 

\mbox{\Hypertarget{namespacergbd__slam_1_1utils_a1f943d571d918b61309edcd6d98f848a}\label{namespacergbd__slam_1_1utils_a1f943d571d918b61309edcd6d98f848a}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::ostream \& rgbd\+\_\+slam\+::utils\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os,  }\item[{const \mbox{\hyperlink{classrgbd__slam_1_1utils_1_1_pose}{Pose}} \&}]{pose }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacergbd__slam_1_1utils_a7830f2322d077dd3b0659ac1226daa5f}\label{namespacergbd__slam_1_1utils_a7830f2322d077dd3b0659ac1226daa5f}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{operator$<$$<$()}{operator<<()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::ostream \& rgbd\+\_\+slam\+::utils\+::operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os,  }\item[{const \mbox{\hyperlink{classrgbd__slam_1_1utils_1_1_pose_base}{Pose\+Base}} \&}]{pose }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacergbd__slam_1_1utils_a9dbca5ba1fde9dede66b983bcdd6b8d0}\label{namespacergbd__slam_1_1utils_a9dbca5ba1fde9dede66b983bcdd6b8d0}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!screen\_to\_world\_coordinates@{screen\_to\_world\_coordinates}}
\index{screen\_to\_world\_coordinates@{screen\_to\_world\_coordinates}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{screen\_to\_world\_coordinates()}{screen\_to\_world\_coordinates()}}
{\footnotesize\ttfamily const \mbox{\hyperlink{structrgbd__slam_1_1world_coordinates}{world\+Coordinates}} rgbd\+\_\+slam\+::utils\+::screen\+\_\+to\+\_\+world\+\_\+coordinates (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structrgbd__slam_1_1screen_coordinates}{screen\+Coordinates}} \&}]{screen\+Point,  }\item[{const \mbox{\hyperlink{structrgbd__slam_1_1camera_to_world_matrix}{camera\+To\+World\+Matrix}} \&}]{camera\+To\+World }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacergbd__slam_1_1utils_aa4613bdb56bd3012bd4efae167362569}\label{namespacergbd__slam_1_1utils_aa4613bdb56bd3012bd4efae167362569}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!world\_to\_camera\_coordinates@{world\_to\_camera\_coordinates}}
\index{world\_to\_camera\_coordinates@{world\_to\_camera\_coordinates}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{world\_to\_camera\_coordinates()}{world\_to\_camera\_coordinates()}}
{\footnotesize\ttfamily const \mbox{\hyperlink{structrgbd__slam_1_1camera_coordinates}{camera\+Coordinates}} rgbd\+\_\+slam\+::utils\+::world\+\_\+to\+\_\+camera\+\_\+coordinates (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structrgbd__slam_1_1world_coordinates}{world\+Coordinates}} \&}]{world\+Coordinates,  }\item[{const \mbox{\hyperlink{structrgbd__slam_1_1world_to_camera_matrix}{world\+To\+Camera\+Matrix}} \&}]{world\+To\+Camera }\end{DoxyParamCaption})}



Transform a vector in world space to a vector in camera space. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em \mbox{\hyperlink{structrgbd__slam_1_1world_coordinates}{world\+Coordinates}}} & A vector in world space \\
\hline
\mbox{\texttt{ in}}  & {\em world\+To\+Camera} & Matrix to transform the world to a local coordinate system\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The input vector transformed to camera space 
\end{DoxyReturn}


\doxysubsection{Variable Documentation}
\mbox{\Hypertarget{namespacergbd__slam_1_1utils_a7c711197a8776f474dea42a34838b675}\label{namespacergbd__slam_1_1utils_a7c711197a8776f474dea42a34838b675}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!MAX\_DEPTH\_DISTANCE@{MAX\_DEPTH\_DISTANCE}}
\index{MAX\_DEPTH\_DISTANCE@{MAX\_DEPTH\_DISTANCE}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{MAX\_DEPTH\_DISTANCE}{MAX\_DEPTH\_DISTANCE}}
{\footnotesize\ttfamily const double rgbd\+\_\+slam\+::utils\+::\+MAX\+\_\+\+DEPTH\+\_\+\+DISTANCE = 6000}

\mbox{\Hypertarget{namespacergbd__slam_1_1utils_afb0e42e07f9e12d67543af504e440506}\label{namespacergbd__slam_1_1utils_afb0e42e07f9e12d67543af504e440506}} 
\index{rgbd\_slam::utils@{rgbd\_slam::utils}!MIN\_DEPTH\_DISTANCE@{MIN\_DEPTH\_DISTANCE}}
\index{MIN\_DEPTH\_DISTANCE@{MIN\_DEPTH\_DISTANCE}!rgbd\_slam::utils@{rgbd\_slam::utils}}
\doxysubsubsection{\texorpdfstring{MIN\_DEPTH\_DISTANCE}{MIN\_DEPTH\_DISTANCE}}
{\footnotesize\ttfamily const double rgbd\+\_\+slam\+::utils\+::\+MIN\+\_\+\+DEPTH\+\_\+\+DISTANCE = 40}

