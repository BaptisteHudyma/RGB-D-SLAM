\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{structrgbd__slam_1_1pose_estimation_1_1compute__features__data}{rgbd\+\_\+slam\+::pose\+Estimation\+::compute\+\_\+features\+\_\+data}} \\*Container storing an image, feature detectors, camera parameters, image division in search regions, .. }{\pageref{structrgbd__slam_1_1pose_estimation_1_1compute__features__data}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1primitive_detection_1_1_cylinder}{rgbd\+\_\+slam\+::primitive\+Detection\+::\+Cylinder}} \\*Specification of the \mbox{\hyperlink{classrgbd__slam_1_1primitive_detection_1_1_primitive}{Primitive}} class. Handles cylinder primitives }{\pageref{classrgbd__slam_1_1primitive_detection_1_1_cylinder}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1primitive_detection_1_1_cylinder___segment}{rgbd\+\_\+slam\+::primitive\+Detection\+::\+Cylinder\+\_\+\+Segment}} \\*Stored a cylinder segment. Computes the parameters (radius, normal of the main axis, eigen values) with a RANSAC fitting }{\pageref{classrgbd__slam_1_1primitive_detection_1_1_cylinder___segment}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1primitive_detection_1_1_depth___operations}{rgbd\+\_\+slam\+::primitive\+Detection\+::\+Depth\+\_\+\+Operations}} \\*Handles operations on the initial depth image, to transform it on a connected cloud points. It also handles the loading of the camera parameters from the configuration file }{\pageref{classrgbd__slam_1_1primitive_detection_1_1_depth___operations}}{}
\item\contentsline{section}{\mbox{\hyperlink{structrgbd__slam_1_1utils_1_1_global___pose___estimator}{rgbd\+\_\+slam\+::utils\+::\+Global\+\_\+\+Pose\+\_\+\+Estimator}} \\*Implementation of the main pose and orientation optimisation, to be used by the Levenberg Marquard optimisator }{\pageref{structrgbd__slam_1_1utils_1_1_global___pose___estimator}}{}
\item\contentsline{section}{\mbox{\hyperlink{structrgbd__slam_1_1utils_1_1_global___pose___functor}{rgbd\+\_\+slam\+::utils\+::\+Global\+\_\+\+Pose\+\_\+\+Functor}} }{\pageref{structrgbd__slam_1_1utils_1_1_global___pose___functor}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1primitive_detection_1_1_histogram}{rgbd\+\_\+slam\+::primitive\+Detection\+::\+Histogram}} \\*Basic 2D \mbox{\hyperlink{classrgbd__slam_1_1primitive_detection_1_1_histogram}{Histogram}} class, handling an histogram of N x N }{\pageref{classrgbd__slam_1_1primitive_detection_1_1_histogram}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1pose_estimation_1_1_image___features___handler}{rgbd\+\_\+slam\+::pose\+Estimation\+::\+Image\+\_\+\+Features\+\_\+\+Handler}} \\*Main image feature detection class. Computes image features and provide methods for feature matching }{\pageref{classrgbd__slam_1_1pose_estimation_1_1_image___features___handler}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1pose_estimation_1_1_image___features___struct}{rgbd\+\_\+slam\+::pose\+Estimation\+::\+Image\+\_\+\+Features\+\_\+\+Struct}} \\*Stores a list of keypoints (features) and provide methods to find a match of a point in those features }{\pageref{classrgbd__slam_1_1pose_estimation_1_1_image___features___struct}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1utils_1_1_key___point___extraction}{rgbd\+\_\+slam\+::utils\+::\+Key\+\_\+\+Point\+\_\+\+Extraction}} \\*A class to detect and store keypoints }{\pageref{classrgbd__slam_1_1utils_1_1_key___point___extraction}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1utils_1_1_keypoint___handler}{rgbd\+\_\+slam\+::utils\+::\+Keypoint\+\_\+\+Handler}} }{\pageref{classrgbd__slam_1_1utils_1_1_keypoint___handler}}{}
\item\contentsline{section}{\mbox{\hyperlink{structrgbd__slam_1_1utils_1_1_levenberg___marquard___functor}{rgbd\+\_\+slam\+::utils\+::\+Levenberg\+\_\+\+Marquard\+\_\+\+Functor$<$ \+\_\+\+Scalar, NX, NY $>$}} \\*Structure given to the Levenberg-\/\+Marquardt algorithm. It optimizes a rotation (quaternion) and a translation (vector3) using the matched features from a frame to the local map, using their distances to one another as the main metric }{\pageref{structrgbd__slam_1_1utils_1_1_levenberg___marquard___functor}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1map__management_1_1_local___map}{rgbd\+\_\+slam\+::map\+\_\+management\+::\+Local\+\_\+\+Map}} \\*Maintain a local map around the camera. Can return matched features, and update the global map when features are estimated to be reliable. For now we dont have a global map }{\pageref{classrgbd__slam_1_1map__management_1_1_local___map}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1pose_estimation_1_1_local___map}{rgbd\+\_\+slam\+::pose\+Estimation\+::\+Local\+\_\+\+Map}} }{\pageref{classrgbd__slam_1_1pose_estimation_1_1_local___map}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1utils_1_1_map___point}{rgbd\+\_\+slam\+::utils\+::\+Map\+\_\+\+Point}} \\*A map point structure, containing all the necessary informations to identify a map point }{\pageref{classrgbd__slam_1_1utils_1_1_map___point}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_monocular___depth___map}{Monocular\+\_\+\+Depth\+\_\+\+Map}} \\*Depth map estimation based on monocular RGB image tracking }{\pageref{class_monocular___depth___map}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1pose_estimation_1_1_motion___model}{rgbd\+\_\+slam\+::pose\+Estimation\+::\+Motion\+\_\+\+Model}} \\*Dead reckoning class\+: guess next pose using a motion model }{\pageref{classrgbd__slam_1_1pose_estimation_1_1_motion___model}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1_parameters}{rgbd\+\_\+slam\+::\+Parameters}} }{\pageref{classrgbd__slam_1_1_parameters}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1pose_estimation_1_1_parameters}{rgbd\+\_\+slam\+::pose\+Estimation\+::\+Parameters}} \\*Load camera parameters from configuration file }{\pageref{classrgbd__slam_1_1pose_estimation_1_1_parameters}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1primitive_detection_1_1_plane}{rgbd\+\_\+slam\+::primitive\+Detection\+::\+Plane}} \\*Specification of the \mbox{\hyperlink{classrgbd__slam_1_1primitive_detection_1_1_primitive}{Primitive}} class. Handles planes }{\pageref{classrgbd__slam_1_1primitive_detection_1_1_plane}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1primitive_detection_1_1_plane___segment}{rgbd\+\_\+slam\+::primitive\+Detection\+::\+Plane\+\_\+\+Segment}} \\*Node class representing a depth graph point. Used to find planes in a depth image. Mainly inspired from CAPE program }{\pageref{classrgbd__slam_1_1primitive_detection_1_1_plane___segment}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1pose_estimation_1_1_p_n_p___solver}{rgbd\+\_\+slam\+::pose\+Estimation\+::\+PNP\+\_\+\+Solver}} \\*Compute a pose estimation }{\pageref{classrgbd__slam_1_1pose_estimation_1_1_p_n_p___solver}}{}
\item\contentsline{section}{\mbox{\hyperlink{structrgbd__slam_1_1utils_1_1_point}{rgbd\+\_\+slam\+::utils\+::\+Point}} \\*Basic keypoint class }{\pageref{structrgbd__slam_1_1utils_1_1_point}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1pose_estimation_1_1_pose}{rgbd\+\_\+slam\+::pose\+Estimation\+::\+Pose}} \\*Store a position }{\pageref{classrgbd__slam_1_1pose_estimation_1_1_pose}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1utils_1_1_pose___optimization}{rgbd\+\_\+slam\+::utils\+::\+Pose\+\_\+\+Optimization}} }{\pageref{classrgbd__slam_1_1utils_1_1_pose___optimization}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1pose_estimation_1_1_pose___utils}{rgbd\+\_\+slam\+::pose\+Estimation\+::\+Pose\+\_\+\+Utils}} }{\pageref{classrgbd__slam_1_1pose_estimation_1_1_pose___utils}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1primitive_detection_1_1_primitive}{rgbd\+\_\+slam\+::primitive\+Detection\+::\+Primitive}} \\*A base class used to compute the tracking analysis. It is a pure virtual class }{\pageref{classrgbd__slam_1_1primitive_detection_1_1_primitive}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1primitive_detection_1_1_primitive___detection}{rgbd\+\_\+slam\+::primitive\+Detection\+::\+Primitive\+\_\+\+Detection}} \\*Main extraction class. Extracts shape primitives from an organized cloud of points }{\pageref{classrgbd__slam_1_1primitive_detection_1_1_primitive___detection}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1pose_estimation_1_1_r_g_b___s_l_a_m}{rgbd\+\_\+slam\+::pose\+Estimation\+::\+RGB\+\_\+\+SLAM}} \\*SLAM algorithm based on special points tracking in a local map }{\pageref{classrgbd__slam_1_1pose_estimation_1_1_r_g_b___s_l_a_m}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1_r_g_b_d___s_l_a_m}{rgbd\+\_\+slam\+::\+RGBD\+\_\+\+SLAM}} }{\pageref{classrgbd__slam_1_1_r_g_b_d___s_l_a_m}}{}
\item\contentsline{section}{\mbox{\hyperlink{classrgbd__slam_1_1utils_1_1_staged___point}{rgbd\+\_\+slam\+::utils\+::\+Staged\+\_\+\+Point}} }{\pageref{classrgbd__slam_1_1utils_1_1_staged___point}}{}
\end{DoxyCompactList}
